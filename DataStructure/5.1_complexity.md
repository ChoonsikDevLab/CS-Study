# 5.1 복잡도

## 5.1.1 시간 복잡도
- **시간 복잡도**: 입력 크기에 대해 알고리즘이 실행되는 데 걸리는 시간
- **빅오 표기법**: 입력 범위 n을 기준으로 로직이 몇 번이나 반복되는지 나타내는 것
- 즉, 시간 복잡도는 효율적인 코드로 개선하는 데 사용되는 척도가 됨.

## 5.1.2 공간 복잡도
- **공간 복잡도**: 프로그램 실행 시 필요로 하는 자원 공간의 양
- 정적 변수 이외에도 동적으로 재귀적인 함수를 사용할 경우 추가 공간이 필요함.

## 5.1.3 자료 구조에서의 시간 복잡도
- 자료 구조를 사용할 때는 평균 시간 복잡도와 최악의 시간 복잡도를 모두 고려해야 함.

### 자료 구조의 평균 시간 복잡도

| 자료 구조               | 접근     | 탐색     | 삽입     | 삭제     |
|------------------------|----------|----------|----------|----------|
| 배열(array)            | O(1)     | O(n)     | O(n)     | O(n)     |
| 스택(stack)            | O(n)     | O(n)     | O(1)     | O(1)     |
| 큐(queue)              | O(n)     | O(n)     | O(1)     | O(1)     |
| 이중 연결 리스트(doubly linked list) | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블(hash table) | O(1) | O(1) | O(1) | O(1) |
| 이진 탐색 트리(BST)    | O(log n) | O(log n) | O(log n) | O(log n) |
| AVL 트리               | O(log n) | O(log n) | O(log n) | O(log n) |
| 레드 블랙 트리         | O(log n) | O(log n) | O(log n) | O(log n) |

### 자료 구조의 최악의 시간 복잡도

| 자료 구조               | 접근     | 탐색     | 삽입     | 삭제     |
|------------------------|----------|----------|----------|----------|
| 배열(array)            | O(1)     | O(n)     | O(n)     | O(n)     |
| 스택(stack)            | O(n)     | O(n)     | O(1)     | O(1)     |
| 큐(queue)              | O(n)     | O(n)     | O(1)     | O(1)     |
| 이중 연결 리스트(doubly linked list) | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블(hash table) | O(n) | O(n) | O(n) | O(n) |
| 이진 탐색 트리(BST)    | O(n)     | O(n)     | O(n)     | O(n)     |
| AVL 트리               | O(log n) | O(log n) | O(log n) | O(log n) |
| 레드 블랙 트리         | O(log n) | O(log n) | O(log n) | O(log n) |

- **해시 테이블**과 **이진 탐색 트리**에서 최악의 경우 모든 연산이 O(n)이 될 수 있음. 이는 충돌이 많이 발생하거나 트리가 편향된 구조일 경우 발생할 수 있음.
- **AVL 트리**와 **레드 블랙 트리**는 균형을 유지하는 트리 구조로, 모든 연산에서 O(log n)의 시간 복잡도를 보장함.

# 5.1 예상 질문

<details>
<summary>

### 1. 시간 복잡도와 공간 복잡도의 차이점을 설명해주세요.
</summary>

```
시간 복잡도는 알고리즘이 문제를 해결하는 데 필요한 시간의 양을 나타내며, 주로 빅오 표기법을 사용하여 표현됩니다.
공간 복잡도는 알고리즘이 실행될 때 필요로 하는 총 저장 공간의 양을 나타내며, 마찬가지로 빅오 표기법으로 표현할 수 있습니다.

시간 복잡도는 알고리즘의 실행 속도와 직접적으로 관련이 있고, 공간 복잡도는 메모리 사용량과 관련이 있습니다.
```

</details>

<details>
<summary>

### 2. 해시 테이블의 시간 복잡도가 O(1)인 이유를 설명해주세요.

</summary>

```
해시 테이블은 key-value가 1:1 매핑되어 있기 때문에 검색, 삽입, 삭제 과정에서 모두 평균적으로 O(1)의 시간복잡도를 갖습니다.
하지만 최악의 경우(모든 키가 같은 인덱스로 해싱되는 경우)에는 모든 항목을 검색해야 하므로 시간 복잡도가 O(n)이 될 수 있습니다.
```

</details>

<details>
<summary>

### 3. 대용량 데이터 검색에서 리스트와 배열 중 어느 것이 더 효율적인지 이유를 설명해주세요.

</summary>

```
데이터가 많아질 경우, 검색에 있어서 배열은 O(n)의 시간 복잡도를 갖습니다.
배열의 각 요소를 차례대로 검사해야 하기 때문입니다.

반면, 리스트(특히 정렬된 경우)는 이진 검색을 사용할 수 있어 검색 시간 복잡도가 O(log n)이 될 수 있습니다.
하지만 리스트가 정렬되어 있어야 하며, 일반적인 연결 리스트에서는 O(n)의 시간이 소요됩니다.

데이터 삽입과 삭제가 빈번하지 않은 대용량 데이터에서는 검색 성능을 우선시하여 정렬된 배열의 사용하는 것이 효율적입니다.
```

</details>

&nbsp;
※ 더 자세한 내용은 [블로그](https://mandusitstudy.tistory.com/317)에서 확인해 주세요.