# 3. 비선형 자료 구조
데이터 요소들이 순차적으로 배열되지 않은 형태(계층적, 네트워크 등)의 자료구조

<br>

## 그래프(Graph)
- 정점(Vertex)이라 불리는 데이터를 간선(edge) 혹은 링크(Link)로 연결한 형태의 자료구조
- 데이터 간의 **연결 관계**를 표현하는 데 쓰임

<br>

**트리와 일반적인 그래프의 차이**
- 트리 : 사이클을 형성하지 않고 연결된 노드 간 상하 관계를 갖음
- 일반적인 그래프 : 사이클을 형성할 수 있으며, 이웃한 정점끼리 상하 관계를 갖지 않음

<img width="518" alt="Image" src="https://github.com/user-attachments/assets/ab9324d5-8ef6-4426-a096-5ac8ff5e49dc" />

간선이 어떠한 형태로 정점을 연결하느냐에 따라 그래프의 종류가 달라질 수 있다.

<br>

### 그래프의 종류
#### 연결/비연결 그래프
- 연결 그래프(Connected Graph) : 그래프 상에 있는 임의의 두 정점 사이의 경로가 존재하는 그래프
- 비연결 그래프(Disconnected Graph) : 어떤 정점 사이에는 경로가 존재하지 않을 수 있는 그래프

<img width="523" alt="Image" src="https://github.com/user-attachments/assets/0727e6a3-9845-4d34-81d1-833110182243" />


#### 방향/무방향 그래프
- 간선에 방향 유무에 따라 나뉘는 그래프

- 방향 그래프(Directed Graph) : 방향이 있는 그래프
- 무방향 그래프(Undirected Graph) : 방향이 없는 그래프

![Image](https://github.com/user-attachments/assets/fd3d68c9-6681-46c5-8567-3c43bfc77786)


#### 가중치 그래프
- 가중치 그래프(Weighted Graph) : 간선에 가중치가 부여된 그래프 

- 가중치 (간선에 부여된 값)는 비용(Cose)이라고 불림
	예 : 역과 역의 사이의 거리 -> 가중치
	  최단 경로 알고리즘(다익스트라(Dijkstra))

- 가중치는 음수가 될 수 있음
- 간선에 부여할 수 있는 값이면 양수, 음수 모두 가능


#### 서브 그래프
- 서브 그래프(Subgraph) : 특정 그래프의 정점과 간선의 일부분으로 이루어진 그래프
	부분 그래프라고도 불림

- 예 : H1, H2, H3는 그래프 G의 서브 그래프 
![Image](https://github.com/user-attachments/assets/fd3d68c9-6681-46c5-8567-3c43bfc77786)


#### 인접 리스트 기반 그래프 표현
- 인접 리스트(Adjacency list) 기반 표현 : 그래프의 특정 정점과 연결된 정점들을 연결 리스트로 표현하는 방법
- CS 기술 면접 320p 참고

<br>

### 깊이 우선 탐색과 너비 우선 탐색
#### 깊이 우선 탐색(DFS, Depth First Search)
- 그래프에서 더 이상 방문 가능한 정점이 없을 때까지 최대한 깊이 탐색을 반복하는 탐색 방법
- 한 경로를 끝까지 탐색한 후, 다른 경로를 탐색함
- 깊이를 우선으로 탐색하여, 재귀 함수나 스택을 이용해 구현
- 예 : 미로 찾기, 경로 특징 저장 문제 등


**동작 과정**
1. 시작 노드에서 출발하여 방문하지 않은 노드를 따라가며 탐색을 진행
2. 더 이상 방문할 노드가 없다면, 이전 노드로 돌아가 다른 경로를 탐색 (백트래킹)

**시간 복잡도**
- 인접 행렬 : O(V^2)
- 인접 리스트 : O(V+E)
    (V: 노드 수, E: 간선 수)

**장점**
- 메모리 사용량이 적음 (현재 경로만 저장)
- 목표 노드가 깊은 단계에 있을 경우 빠르게 도달 가능

**단점**
- 해가 없는 경로에 깊이 빠질 가능성이 있음
- 최단 경로를 보장하지 않음


#### 너비 우선 탐색(BFS, Breadth First Search)
- 최대한 넓게 탐색을 반복하는 방법
- 인접한 모든 정점들을 방문 → 방문한 정점들과 연결된 모든 정점 방문 → 이어 방문한 정점들과 연결된 모든 정점을 방문하는 것을 반복하는 탐색 방법
- 큐(Queue)를 이용하여 구현
- 예 : 최단 경로 문제, 네트워크 연결 확인 등

**동작 과정**
1. 시작 노드를 큐에 넣고 방문 표시
2. 큐에서 노드를 꺼내고, 해당 노드의 인접 노드를 큐에 추가하여 탐색을 진행
3. 큐가 빌 때 까지 반복

**시간 복잡도**
- 인접 행렬 : O(V^2)
- 인접 리스트 : O(V+E)  

**장점**
- 최단 경로를 보장함 (가중치 없는 그래프에서)
- 모든 연결된 구성 요소를 탐색할 수 있음

**단점**
- 메모리 사용량이 많음 (큐에 모든 인접 노드를 저장하기 때문)
- 분기 계수가 큰 그래프에서는 비효율적

#### 최단 경로 알고리즘
- 한 정점에서 목적지 정점까지 이르는 가중치의 합이 최소가 된는 경로를 결정하는 알고리즘
- 예 : 지도 서비스, 네트워크 등
- 대표 알고리즘 : 다익스트라 알고리즘(Dijkstra's algorithm)

##### 다익스트라 알고리즘(Dijkstra's algorithm)
- 간선의 가중치가 음이 아닌 수라는 가정 하에 사용 가능한 최단 경로 알고리즘
- 특정 정점에 이르는 거리를 저장한 데이터(aka. 테이블 / ex. 배열)가 함께 사용됨

1. 최단 거리 테이블 상에서 시작 정점을 제외한 정점들은 모두 충분히 큰 수로 초기화
2. (시작)정점을 방문
3. 방문한 정점과 인접한 정점들을 탐색
4. 경로 상의 가중치 합과 최단 거리 테이블 상의 값을 비교
5. 최단 거리 테이블을 생신할 수 있다면 갱신
6. 방문하지 않은 정점 중 최단 거리가 가장 작은 정점을 방문
7. 더 이상 방문할 정점이 없을 때까지 3~6 과정을 반복하고 종료료

<br>

## 트리(Tree)
- 계층적인 구조를 표현하기 위한 자료구조

![image](https://github.com/user-attachments/assets/960ac01b-301b-4952-a962-2df4c0448fa9)

- 노드(Node) : 데이터를 저장하는 기본 단위
- 간선(Edge) : 노드와 노드를 연결하는 선 (링크(Link)라고도 불림)
- 루트 노드(Root Node) : 트리 최상위 노드
- 리프 노드(Leaf Node) : 자식이 없는 최하단 말단 노드
- 부모 노드(Parent Node) : 특정 노드의 상위 노드
- 자식 노드(Child Node) : 특정 노드의 하위 노드
- 형제 노드(Sibling Node) : 같은 부모 노드를 공유하는 노드
- 조상 노드(Ancestor Node) : 부모 노드 및 상위 부모 노드들
- 자손 노드(Descendant Node) : 자식 노드 및 하위 자식 노드들


![image](https://github.com/user-attachments/assets/e12d78fd-08b8-4c82-84ab-af84879214cb)

- 차수 (Degree) : 특정 노드가 가지고 있는 자식 노드의 수
- 레벨(Level) : 루트 노드에서 시작해 특정 노드에 이르기 까지 거치는 간선의 수
- 서브 트리(SubTree) : 트리에 포함되어 있는 부분 트리
- 깊이(Depth)
- 높이(Height)

<br>

### 트리의 순회(Tree Traversal)
- 트리의 모든 노드를 한 번씩 방문하는 것
- 대표적으로 3가지 방법이 존재

- 전위 순회: 루트 노드 → 왼쪽 서브트리 전위 순회 → 오른쪽 서브트리 전위 순회
- 중위 순회: 왼쪽 서브트리 중위 순회 → 루트 노드 → 오른쪽 서브트리 중위 순회
- 후위 순회: 왼쪽 서브트리 후위 순회 → 오른쪽 서브트리 후위 순회 → 루트 노드

![image](https://github.com/user-attachments/assets/4a87b06e-1625-4720-bb26-1a6435e0c593)


- 전위 순회: a → b → d → h → i → e → j → k → c → f → l → g
- 중위 순회: h → d → i → b → j → e → k → a → l → f → c → g
- 후위 순회: h → i → d → j → k → e → b → l → f → g → c → a


### 이진 트리(Binary Tree)

![image](https://github.com/user-attachments/assets/cf943b86-f85a-4a09-be40-9a6d0d17c6da)

- 각 노드가 최대 두 개의 자식을 가지는 트리


- 정이진 트리 : 자식 노드의 수가 1개가 아닌 이진 트리
- 완전 이진 트리 : 마지막 레벨을 제외한 모든 레벨이 2개의 자식 노드를 가지고 있으며, 마지막 레벨의 모든 노드들이 왼쪽부터 존재한 이진 트리
- 변질 이진 트리(편향 이진 트리) : 자식 노드가 하나밖에 없는 이진 트리 (한쪽으로 치우친 이진 트리)
- 포화 이진 트리 : 리프 노드를 제외한 모든 노드들이 자식 노드를 2개씩 가지고, 모든 리프 노드들의 레벨이 동일한 이진 트리
- 균형 이진 트리 : 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진  트리

#### 이진 탐색 트리(Binary Search Tree, BST)
- 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드의 순서로 정렬된 이진 트리
- 탐색, 삽입, 삭제 연산의 시간 복잡도가 평균 O(log n)
 
#### AVL 트리(Adelson-Velsky and Landis Tree)
- 균형 이진 탐색 트리
- 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 트리

#### 레드-블랙 트리(RB Tree)
- 균형 이진 탐색 트리의 일종
- 각 노드에 색깔을 부여하여 균형을 유지

### B 트리
- 다진 트리(Multi-way Tree)의 일종
- 데이터베이스와 파일 시스템에서 널리 사용됨

<br>

## 힙(Heap)
- 완전 이진 트리 구조를 기반으로 하는 자료구조

- 완전 이진 트리 : 모든 레벨이 완전히 채워져 있으며, 마지막 레벨은 왼쪽부터 차례로 채워진다.
- 힙 성질 : 부모 노드와 자식 노드 사이 대소 관계가 성립한다.
- 효율적인 삽입&삭제 : 최악의 경우에도 O(log n)의 시간 복잡도를 가진다.

<br>

힙은 두 가지 유형으로 나뉜다.
- **최대힙(Max Heap)** : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
- **최소힙(Min Heap)** : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

![image](https://github.com/user-attachments/assets/01d8242c-23b1-40ac-bc41-2aa85e8456e5)

<br>

힙의 주요 연산은 다음과 같다.
- **최대힙 삽입** : 새로운 요소를 힙 마지막에 추가하고, 힙 성질을 만족할 때까지 부모 노드들과 크기를 비교하며 교환한다.
- **최대힙 삭제** : 루트 노드(최대값)를 삭제하고, 마지막 노드를 루트로 이동시킨 후 힙 성질을 만족할 때까지 스왑하며 재구성한다.  

<br>

## 맵(Map)

- 특정 순서에 따라 Key Value 형태의 조합으로 구성된 자료구조

- 각 Key는 유일해야하며, 중복된 Key는 허용하지 않는다.
- Key를 통해 빠르게 값에 접근할 수 있다.
- 해시 테이블이나 이진 탐색 트리(레브 블랙 트리) 구조로 구현된다. 

**주요 연산**
- 삽입
- 삭제
- 검색
- 수정

**활용 예시**
- 사전(Dictionary)
- 캐시(Cache)
- 데이터베이스 인덱싱

<br>

**자바 코드 예시**
```java
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // HashMap 생성
        Map<String, Integer> fruitMap = new HashMap<>();

        // 요소 추가
        fruitMap.put("사과", 5);
        fruitMap.put("바나나", 3);
        fruitMap.put("오렌지", 2);

        // 요소 접근
        System.out.println("사과의 개수: " + fruitMap.get("사과"));

        // 요소 순회
        for (Map.Entry<String, Integer> entry : fruitMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue() + "개");
        }

        // 요소 존재 여부 확인
        if (fruitMap.containsKey("바나나")) {
            System.out.println("바나나가 있습니다.");
        }

        // 요소 제거
        fruitMap.remove("오렌지");

        // 크기 확인
        System.out.println("과일 종류: " + fruitMap.size() + "개");
    }
}
```

<br>

## 셋(Set)
중복된 요소가 없고 Unique 값만 저장하는 자료구조

- 모든 요소는 유일해야하며, 중복된 요소는 허용되지 않는다.
- 요소의 순서는 고려하지 않는다.

**주요 연산**
- 삽입
- 삭제
- 검색
- 집합 연산

**활용 예시**
- 중복 제거
- 고유 값 관리
- 집합 연산이 필요한 알고리즘 

<br>

**자바 코드 예시**

```java
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // HashSet 생성
        Set<String> colorSet = new HashSet<>();

        // 요소 추가
        colorSet.add("빨강");
        colorSet.add("파랑");
        colorSet.add("초록");
        colorSet.add("빨강");  // 중복 요소는 무시됨

        // 요소 개수 출력
        System.out.println("색상 개수: " + colorSet.size());

        // 요소 순회
        for (String color : colorSet) {
            System.out.println(color);
        }

        // 요소 존재 여부 확인
        if (colorSet.contains("파랑")) {
            System.out.println("파랑색이 포함되어 있습니다.");
        }

        // 요소 제거
        colorSet.remove("초록");

        // 모든 요소 제거
        colorSet.clear();

        // 비어있는지 확인
        if (colorSet.isEmpty()) {
            System.out.println("Set이 비어있습니다.");
        }
    }
}
```

<br>

## 해시 테이블(Hash Table)
키(Key), 값(Value)의 쌍으로 이루어진 자료구조

- **Key Value 쌍** : 키는 해시 테이블에 대한 입력, 값은 키를 통해 얻고자 하는 데이터
- **빠른 검색 속도** : O(1)의 시간 복잡도를 가지고 있다.
- **해시 함수** : 키를 입력 받아, 해시 값(Index)를 생성하는 함수를 사용한다.

- **버킷(Bucket)** : 키를 통해 얻고자 하는 데이터가 저장된 곳


![image](https://github.com/user-attachments/assets/637d9a8d-13be-45b6-a4cd-bcc1220113ed)

<br>

### 해시 함수(Hash Function)
임의의 길이를 가진 데이터를 고정된 길이의 데이터로 변환하는 단뱡항 함수

- **해시 알고리즘(Hash Algorithm)** : 해시 함수의 연산 방법
대표적으로 MD5, SHA-1, SHA-256, SHA-512, SHA3, HMAC 등이 존재

### 주요 활용처
- 단방향 암호를 만들 때
- 데이터의 무결성을 검증할 때

#### 데이터의 무결성을 검증
![image](https://github.com/user-attachments/assets/a6caa269-8cf4-41f6-aa45-1d25357cee11)


#### 단방향 암호화
비밀번호를 저장할 때 활용된다.
대표적인 알고리즘은 bcrypt, PBKDF2, scrypt, argon2 등이 존재

국내에서는 **개인정보의 안전성 확보조치 기준** 제 7조에 명시되어 있다.
![image](https://github.com/user-attachments/assets/a30aeb05-8110-45ea-b645-b3d0481309e6)

<br>

### 해시 충돌
- 서로 다른 키에 대해 같은 해시 값이 대응되는 상황

**대표적인 해결 방법**
- 개방 주소법(Open Addressing)
- 체이닝(Chaining)
- 이중 해싱(Double Hashing)

#### 체이닝
총돌이 발생한 데이터를 연결 리스트(또는 트리)를 이용하여 저장하는 방식

#### 개방 주소법
충돌이 발생한 공간(버킷)이 아닌 다른 공간을 찾아 데이터를 저장하는 방법

#### 이중 해싱
충돌이 발생했을 때 다른 해시 함수(보조 해시 함수)에 대한 해시 값만큼 떨어진 거리에서 인덱스를 찾는 방법

<br>
<br>

# 예상 질문

<details>
<summary>
트리와 그래프의 차이는 무엇인가요?
</summary>
  
```
그래프는 트리보다 더 포괄적인 개념이고, 트리는 그래프의 특수한 형태라고 할 수 있습니다. 
일반적인 그래프는 사이클을 형성할 수 있고, 이웃한 정점끼리 상하 관계를 갖지 않습니다. 
반면에 트리는 사이클을 형성하지 않고, 연결된 노드 간 계층적인 상하 관계를 갖고 있습니다.
```

</details>

<details>
<summary>
BST(Binary Search Tree)의 정의와 특징은 어떻게 되나요?
</summary>
  
```
트리 자료 구조중 하나이며, 탐색에 활용할 수 있습니다.
특징은 다음과 같습니다.
이진 트리이며, 루트 노드에 대해 왼쪽 자식은 루트 노드보다 작거나 같은 값, 오른쪽 자식은 루트 노드보다 큰 값을 저장하며, 서브 트리도 다음 조건을 만족합니다.
시간복잡도는 O(log n)으로 빠르게 원하는 값을 탐색할 수 있습니다.
다만 균형이 맞지 않고 한쪽으로 치우쳐진 경우에는 트리의 높이 자체가 n이 되어 최악(Worst Case)의 경우 O(n)의 시간복잡도를 갖습니다.
```
  
</details>

<details>
<summary>
인코딩된 값과 해시 값의 차이를 설명해 주세요.
</summary>
  
```
인코딩은 데이터를 다른 방식으로 표현하기 위해 변환하는 것입니다. 인코딩된 값은 디코딩을 거쳐 다시 변환될 수 있습니다. 
예를 들어 base64와 아스키 인코딩은 모두 컴퓨터가 이해하는 코드의 형식으로 변환될 수 있고, 변환된 코드는 사람이 이해할 수 있는 데이터의 형태로 다시 디코딩될 수 있습니다.
해시 값은 해시 함수를 이용해 고정 길이의 임의의 값으로 데이터를 변환한 결과를 말합니다.
해시 함수는 인코딩과는 다르게 단방향 함수이기 때문에 데이터를 다시 변환할 수 없습니다.
또한 해시 함수는 임의 길이의 데이터를 입력 받아 고정된 길이의 해시 값을 출력하고, 입력값이 조금이라도 달라지면 해시 값도 완전히 다른 값으로 변경됩니다.
따라서 인코딩된 값은 주로 데이터를 전송하거나 저장할 때 정해진 다른 형식으로 표현 위해 사용되고, 해시 값은 주로 데이터의 무결성을 검증하거나 데이터를 빠르게 검색하기 위해 사용합니다.
```
  
</details>


<details>
<summary>
해시 테이블의 장담점을 설명해 주세요.
</summary>
  
```
해시 테이블의 장점은 데이터 검색 성능이 빠르다는 것입니다. 해시 테이블에 대한 키가 주어졌다면 해시 테이블의 검색 성능은 O(1)로 매우 빠릅니다.
하지만 데이터가 저장될 공간을 미리 확보해야 하기 때문에 메모리 공간이 많이 사용되는 것이 단점입니다.
```
  
</details>


<details>
<summary>
해시 충돌이 무엇이며, 해결 방법은 어떻게 되나요?
</summary>
  
```
해시 충돌은 서로 다른 키에 대해 같은 해시 값이 대응되는 상황을 말합니다.
해시 충돌은 체이닝과 개방 주소법 등으로 해결할 수 있습니다.
체이닝은 충돌이 발생한 데이터를 연결 리스트(또는 트리)로 충돌된 데이터를 추가하여 저장하는 해결하는 방법이고,
개방 주소법은 충돌이 발생하면 다른 버킷을 찾아 데이터를 저장하는 해결 방법입니다.
```
  
</details>


<br>

# 참고자료
- 이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접 (강민철)
- 면접을 위한 CS 전공지식 노트 (주홍철)
