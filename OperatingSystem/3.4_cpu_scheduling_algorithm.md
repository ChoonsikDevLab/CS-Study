# 3.4 CPU 스케줄링 알고리즘

CPU 스케줄링은 프로세스가 종료될 때 기본적으로 수행되며, 특정 상황에서 실행 중에도 이루어짐. 스케줄링 유형에는 비선점형과 선점형이 있음.
1. **실행 상태에서 입출력 작업을 위해 대기 상태로 전환될 때**
2. **실행 상태에서 타이머 인터럽트에 의해 준비 상태로 변경될 때**

![image](https://github.com/user-attachments/assets/f304ec38-2c16-4cb2-bbc2-b347fbd54b89)
▲ 스케줄링 유형


운영체제는 프로세스에 CPU를 배분하는 다양한 방법을 사용함. 목표는 CPU 이용률을 높이고, 주어진 시간에 가능한 많은 작업을 수행하며, 준비 큐에 있는 프로세스 수를 최소화하고, 응답 시간을 단축하는 것임.

![image](https://github.com/user-attachments/assets/5b258647-3dd5-41cc-89a7-43abd2dda16f)
▲ CPU 스케줄링 알고리즘

### 표: CPU 스케줄링 알고리즘

| 분류    | 알고리즘                    | 특징                                                 | 장점                  | 단점                                            |
|---------|-----------------------------|------------------------------------------------------|-----------------------|-------------------------------------------------|
| 비선점형 | FCFS(First Come, First Served) | 가장 먼저 도착한 프로세스를 처리                     | 간단하고 공정           | 긴 작업 앞에 짧은 작업이 대기할 수 있음 (convoy effect) |
|         | SJF(Shortest Job First)     | 실행 시간이 가장 짧은 프로세스를 먼저 처리           | 평균 대기 시간 최소화   | 긴 작업은 계속 대기할 수 있음 (starvation)      |
|         | 우선순위(Priority)          | 우선순위가 높은 작업을 먼저 처리, aging 사용으로 보완 | 우선순위 기반 작업 처리 | 낮은 우선순위 작업이 계속 대기할 수 있음          |
| 선점형   | 라운드 로빈(Round Robin)     | 각 프로세스에 동일한 시간 할당                        | 공정하고 응답 시간 단축  | 시간 할당량에 매우 민감하며 설정이 중요           |
|         | SRF(Shortest Remaining Time First) | 잔여 시간이 짧은 작업을 먼저 처리                  | 최소 대기 시간 보장     | 빈번한 컨텍스트 스위칭 가능성                     |
|         | 다단계 큐(Multi-level Queue) | 우선순위에 따라 여러 큐 사용, 독립적 정책 적용        | 우선순위별 효율적 처리   | 큐 간 이동 제한으로 유연성 저하                    |

## 3.4.1 비선점형 방식

`비선점형 스케줄링`은 프로세스가 스스로 CPU 소유권을 포기하거나 종료될 때까지 CPU 자원을 독점함. 컨텍스트 스위칭 부하가 적음.

1. **FCFS(First Come, First Served)**: 가장 먼저 도착한 프로세스를 처리. 길게 수행되는 프로세스 때문에 준비 큐에서 오래 대기하는 현상이 발생할 수 있음.
2. **SJF(Shortest Job First)**: 실행 시간이 가장 짧은 프로세스를 먼저 처리. 긴 작업의 계속된 대기로 인한 starvation이 발생할 수 있음.
3. **우선순위(Priority)**: 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행함. Aging을 통해 우선순위를 조정하여 보완함.

## 3.4.2 선점형 방식

`선점형 스케줄링`은 운영체제가 현재 실행 중인 프로세스를 중단시키고 다른 프로세스에 CPU 자원을 강제로 할당함. 컨텍스트 스위칭으로 인한 오버헤드가 발생할 수 있음.

1. **라운드 로빈(Round Robin)**: 각 프로세스에 동일한 시간을 할당하고, 시간 내에 끝나지 않으면 준비 큐의 뒤로 이동함.
2. **SRT/SRF(Shortest Remaining Time First)**: 현재 실행 중인 작업보다 짧은 잔여 시간을 가진 새 작업이 도착하면 즉시 교체함.
3. **다단계 큐**: 우선순위에 따라 여러 준비 큐를 사용하며, 각 큐는 독립적인 스케줄링 정책을 적용함. 큐 간 프로세스 이동이 제한되어 있어 유연성이 떨어짐.
4. **다단계 피드백 큐**: 다단계 큐와 비슷하지만 프로세스들이 큐 사이를 이동할 수 있어 스케줄링의 유연성을 향상시킴.

&nbsp;
※ 더 자세한 내용은 [블로그](https://mandusitstudy.tistory.com/312)에서 확인해 주세요.

# 3.4 예상 질문

<details>
<summary>

### 1. 콘보이 현상(convoy effect, 호위 효과)이란 무엇이고, 콘보이 현상이 발생될 수 있는 CPU 스케줄러 알고리즘은 무엇인지 설명해주세요.

</summary>

```
콘보이 현상이란 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다른 프로세스의 실행을 지연시키는 현상입니다.
이로 인해 시스템 전체의 응답 시간이 길어시고 효율성이 저하됩니다.
콘보이 현상은 FCFS(First Come First Served)와 같은 비선점형 스케줄링 알고리즘에서 발생합니다.
FCFS는 순차적으로 먼저 큐에 들어온 작업부터 실행하므로 콘보이 현상이 발생할 수 있습니다.
```

</details>

<details>
<summary>

### 2. 선점형 스케줄링과 비선점형 스케줄링의 차이를 설명해주세요.

</summary>

```
선점형 스케줄링에서는 현재 CPU를 사용 중인 프로세스를 중단시키고 더 우선 순위가 높은 프로세스에게 CPU를 할당할 수 있습니다.
비선점형 스케줄링에서는 한 번 CPU를 할당받은 프로세스가 완전히 종료되거나 대기 상태로 전환될 때까지 다른 프로세스는 CPU를 사용할 수 없습니다.
```

</details>

<details>
<summary>

### 3. CPU 스케줄링은 언제 발생하는지 설명해주세요.

</summary>

```
CPU 스케줄링은 프로세스의 상태 변화에 따라
1. 실행상태에서 대기상태로 전환될 때(예: 입출력 작업 요청) - Non preemptive(비선점)
2. 실행상태에서 준비상태로 전환될 때(예: 인터럽트 발생) - preemptive(선점)
3. 대기상태에서 준비상태로 전환될 때(예: 입출력 작업 완료)
4. 종료될 때(Terminated)
발생합니다.
```

</details>

## 예상 질문 참고자료
1) https://deious.tistory.com/290
2) https://dev-coco.tistory.com/162