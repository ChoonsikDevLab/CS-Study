## 4.5 인덱스

### 4.5.1 인덱스의 필요성
- **인덱스(Index)**: 데이터를 빠르게 찾을 수 있는 하나의 장치임.

    - 인덱스를 설정하면 테이블 안에서 원하는 데이터를 빠르게 찾을 수 있음.

### 4.5.2 B-트리
- 인덱스는 주로 B-트리라는 자료 구조로 이루어짐.

    - **B-트리**: 루트 노드, 리프 노드, 브랜치 노드로 나뉨.

      ```sql
      -- B-트리 예
                                  [10 | 20]                             --(루트 노드)
                    /                 |                 \
              [5 | 7]             [12 | 15]             [25 | 30]       --(브랜치 노드)
            /   |   \             /      \               /      \
         [1|3] [6] [8|9]       [11]    [13|14]         [22]   [28|29]   --(리프 노드)
      ```
    - 인덱스의 효율성은 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 트리 깊이의 대수확장성 때문임.

### 4.5.3 인덱스 만드는 방법
- 데이터베이스마다 인덱스를 만드는 방법은 다름.

    - **MySQL**:

        - **클러스터형 인덱스**: 테이블당 하나를 설정할 수 있음. 주로 primary key나 unique not null 옵션으로 만들 수 있음.
        - **세컨더리 인덱스**: 보조 인덱스로, 여러 개의 필드 값을 기반으로 쿼리가 많이 이루어질 때 생성해야 하는 인덱스. `CREATE INDEX ...` 명령어로 만들 수 있음.

    - **MongoDB**:

        - 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨. 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있음.

### 4.5.4 인덱스 최적화 기법
- 데이터베이스마다 다르지만 기본 골조는 같음.

    - **MongoDB 기반 인덱스 최적화 기법**:

        - 인덱스는 비용임.

            - 인덱스는 두 번(인덱스 리스트, 컬렉션 순) 탐색하도록 강요함.
            - 컬렉션이 수정되었을 때 인덱스도 수정되어야 함.
            - 쿼리에 있는 필드에 인덱스를 무작정 설정하는 것은 답이 아님.

        - 항상 테스팅해야 함. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에 항상 테스팅하는 것이 중요함.

        - 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 함. 여러 필드를 기반으로 조회할 때 복합인덱스를 생성하는데 아래 생성 순서에 따라 성능이 달라질 수 있음.

## 4.5 예상 질문

<details>
<summary>

### 1. `Index`와 `Index의 장/단점`에 대해 설명해주세요.

</summary>

```
인덱스는 데이터베이스의 검색 속도를 향상시키기 위해 사용되는 자료 구조입니다.
테이블 내의 데이터를 빠르게 찾는 데 도움을 주며, 주로 B-트리 구조로 구현됩니다.
인덱스의 주요 장점은 검색 성능의 향상입니다.
그러나 인덱스를 생성하고 유지하기 위해서는 추가적인 저장 공간이 필요하고, 데이터를 삽입하거나 수정할 때 인덱스를 재구성해야 하기 때문에 성능에 부담을 줄 수 있습니다.
따라서 인덱스는 검색이 자주 이루어지는 필드에 대해서만 신중하게 생성하는 것이 중요합니다.
```

</details>

<details>
<summary>

### 2. 인덱스를 매 필드마다 설정하는 것이 좋을까요?

</summary>

```
모든 필드에 인덱스를 설정하는 것은 비효율적입니다.
인덱스는 데이터를 빠르게 검색하는 데 유용하지만, 데이터 삽입, 삭제, 수정 작업 시 인덱스 역시 업데이트해야 하므로 성능 저하를 일으킬 수 있습니다.
또한, 인덱스는 추가적인 디스크 공간을 차지합니다.
따라서 자주 검색되고, 검색 성능의 향상이 필요한 필드에 대해서만 인덱스를 생성하는 것이 바람직합니다.
```

</details>

<details>
<summary>

### 3. Index의 `B+ 트리`가 무엇인지 설명해주세요.

</summary>

```
B+ 트리는 B-트리의 변형으로, 데이터베이스 인덱스에 널리 사용되는 자료 구조입니다.
B+ 트리는 모든 데이터가 리프 노드에만 저장되며, 내부 노드는 키를 가리키는 데 사용됩니다.
이 구조는 검색, 삽입, 삭제 작업을 균일하게 처리할 수 있도록 돕고, 리프 노드들은 링크드 리스트로 연결되어 범위 검색이나 순차 접근을 최적화합니다.
B+ 트리의 균형 구조로 인해 각 노드의 데이터는 상대적으로 균등하게 분포되며, 이는 대규모 데이터 처리에 효과적입니다.
```

</details>

<details>
<summary>

### 4. `해시 인덱스 방식`과 `B+ 트리 인덱스 방식`의 차이에 대해 설명해주세요.

</summary>

```
해시 인덱스 방식은 키 값을 해싱 알고리즘을 통해 인덱스 키를 생성하고, 이를 사용하여 데이터에 빠르게 접근합니다.
이 방식은 주로 등가 검색(특정 값에 대한 검색)에 유용하지만, 범위 검색이나 정렬된 데이터 접근에는 적합하지 않습니다.
반면, B+ 트리 인덱스 방식은 키와 포인터가 트리 구조를 이루고 있어 등가 검색과 범위 검색 모두에 효율적입니다.
또한, B+ 트리는 리프 노드가 연결 리스트로 연결되어 있어 순차 접근에도 유리합니다.
```

</details>

<details>
<summary>

### 5. DBMS는 Index를 어떻게 관리하고 있나요?(Index 자료구조)

</summary>

```
DBMS는 인덱스를 효율적으로 관리하기 위해 B-트리와 같은 균형 잡힌 트리 구조를 사용합니다.
인덱스는 데이터의 삽입, 삭제, 업데이트 시 동적으로 조정되며, 이러한 변경은 트리의 균형을 유지하기 위해 자동으로 재구성됩니다.
인덱스 관리는 데이터베이스의 성능과 직결되므로, DBMS는 인덱스의 최적화와 효율적인 데이터 접근을 보장하기 위해 내부적으로 다양한 알고리즘과 기법을 적용합니다.
예를 들어, 클러스터형 인덱스는 데이터와 함께 저장되어 빠른 접근을 가능하게 하고, 세컨더리 인덱스는 보조적인 데이터 접근 경로를 제공합니다.
```

</details>

&nbsp;

※ 자세한 내용은 [블로그](https://mandusitstudy.tistory.com/315)를 참고해주세요.